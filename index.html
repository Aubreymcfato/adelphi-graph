<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Literary Citation Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="loader.js"></script>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; display: flex; }
        #graph { flex: 3; height: 100vh; background: #fff; }
        #sidebar { flex: 1; padding: 20px; background: #f0f0f0; overflow-y: auto; height: 100vh; }
        #sidebar h2 { margin-top: 0; }
        .node circle { stroke: #fff; stroke-width: 1.5px; }
        .link { stroke: #999; stroke-opacity: 0.6; }
        .node text { pointer-events: none; font: 12px Arial; fill: #111; font-weight: 300; }
    </style>
</head>
<body>
    <svg id="graph"></svg>
    <div id="sidebar">
        <h2>Dettagli Citazione</h2>
        <p>Clicca su un nodo per vedere le citazioni (da più libri se presenti).</p>
        <div id="nodeDetails"></div>
    </div>
    <script>
        const width = window.innerWidth * 0.75;
        const height = window.innerHeight;

        const svg = d3.select("#graph")
            .attr("width", width)
            .attr("height", height);

        // Container per pan & zoom
        const container = svg.append("g");

        // Attiva pan & zoom
        svg.call(
            d3.zoom()
                .scaleExtent([0.2, 5])
                .on("zoom", (event) => {
                    container.attr("transform", event.transform);
                })
        );

        // Carica la lista dei file JSON automaticamente
        getJsonFiles().then(jsonFiles => {
            // Carica e mergia i dati come prima
            Promise.all(jsonFiles.map(file => fetch(file).then(res => res.json()))).then(allData => {
                const mergedNodes = new Map();
                const mergedLinks = [];

                allData.forEach(bookData => {
                    if (!mergedNodes.has(bookData.author)) {
                        mergedNodes.set(bookData.author, { id: bookData.author, group: 1 });
                    }
                    bookData.nodes.forEach(node => {
                        if (mergedNodes.has(node.id)) {
                            const existing = mergedNodes.get(node.id);
                            if (!existing.quotes) existing.quotes = [];
                            existing.quotes.push({ book: bookData.book, page: node.page, quote: node.quote });
                        } else {
                            mergedNodes.set(node.id, {
                                id: node.id,
                                group: 2,
                                quotes: [{ book: bookData.book, page: node.page, quote: node.quote }]
                            });
                        }
                    });
                    mergedLinks.push(...bookData.links);
                });

                const nodes = Array.from(mergedNodes.values());
                const links = mergedLinks;

                // Colori personalizzati
                function nodeColor(group) {
                    return group === 1 ? "#8B0000" : "#002366"; // rosso scuro, blu scuro
                }

                const simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id).distance(120).strength(0.9))
                    .force("charge", d3.forceManyBody().strength(-220))
                    .force("center", d3.forceCenter(0, 0));

                // Draw links
                const link = container.append("g")
                    .attr("stroke", "#999")
                    .attr("stroke-opacity", 0.6)
                    .selectAll("line")
                    .data(links)
                    .join("line")
                    .attr("stroke-width", 2);

                // Draw nodes
                const node = container.append("g")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1.5)
                    .selectAll("g")
                    .data(nodes)
                    .join("g")
                    .attr("class", "node")
                    .call(drag(simulation));

                node.append("circle")
                    .attr("r", 20)
                    .attr("fill", d => nodeColor(d.group))
                    .on("click", (event, d) => showNodeDetails(d));

                node.append("text")
                    .attr("dy", 4)
                    .attr("text-anchor", "middle")
                    .text(d => d.id.length > 20 ? d.id.slice(0, 17) + "…" : d.id);

                simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                });

                function showNodeDetails(d) {
                    const detailsDiv = document.getElementById("nodeDetails");
                    if (d.quotes && d.quotes.length) {
                        let html = `<strong>${d.id}</strong><ul>`;
                        d.quotes.forEach(q => {
                            html += `<li><em>${q.book}</em> (pag. ${q.page}): ${q.quote}</li>`;
                        });
                        html += "</ul>";
                        detailsDiv.innerHTML = html;
                    } else {
                        detailsDiv.innerHTML = `<strong>${d.id}</strong><br>Nessuna citazione disponibile.`;
                    }
                }

                function drag(simulation) {
                    function dragstarted(event, d) {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    }
                    function dragged(event, d) {
                        d.fx = event.x;
                        d.fy = event.y;
                    }
                    function dragended(event, d) {
                        if (!event.active) simulation.alphaTarget(0);
                        d.fx = null;
                        d.fy = null;
                    }
                    return d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended);
                }
            });
        });
    </script>
</body>
</html>
